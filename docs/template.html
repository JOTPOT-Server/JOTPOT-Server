<div ID="main-container">
	<style>
		#main-container {
			font-family: Arial, Helvetica, sans-serif;
			background-color: #fff;
			color: #004;
			padding: 8px;
			padding-left: 20px;
			padding-right: 50px;
			text-align: left;
		}
		h1,h2,h3 {
			font-family: Arial, Helvetica, sans-serif;
			color: #008;
		}
		a {
			background-color: #e0e0e0;
			box-sizing: border-box;
			border-radius: 3px;
			padding: 3px;
			color: #008;
		}
		.details {
			padding: 0px;
			font-size: 0.9em;
			padding-left: 15px;
		}
		.details>ul {
			margin: 3px;
			margin-left: -15px;
			font-size: 0.85em;
		}
		.supported {
			color: green;
		}
		.notsupported {
			color: red;
		}
		.func-h3 {
			margin-bottom: 0px;
		}
		.args-list {
			font-size: 1.2em;
			margin-top: 3px;
			margin-bottom: 10px;
			padding-left: 45px;
		}
		.desc {
			font-size: 1.15em;
			padding-left: 55px;
			margin-top: -5px;
		}
		.indent {
			padding-left: 20px;
		}
	</style>
	<h1>JOTPOT Server Docs <span style="font-size: 0.8em;">26B</span><span style="font-size: 0.6em;">-0</span></h1>
	<a href="/server" style="float: right;" ID="the_link">JOTPOT Server Main Page</a>

	<div class="indent">

		<i>Please note that this page is still a work in progress, and is no where near complete. It may not look the best yet but the content should be good :)</i>
		<h2>Quick Links</h2>
		<a href="#server-object">'server' object reference</a>
		<a href="#request-object">'request' object reference</a>
		<a href="#response-object">'response' object reference</a>
		<a href="#url-object">'url' object reference</a>
		<h2>Getting started</h2>
		<div class="indent">
			<p>Welcome the the documentation for JOTPOT Server, this first section is a guide on getting started with JOTPOT Server.</p>
			
			<h3>What is JOTPOT Server???</h3>
			<p>JOTPOT Server is a web server and/or load balencer writen in Node.js and Go.</p>
			<p>It is designed to be easy to setup and use. Once installed (which is simple), you can setup and get a server running in just 2 commands, and customizing it is as simple as changing a json file.</p>
			<p>If you want to go super simple, JOTPOT Server can be a great solution for a simple file server without having to change the config, it can even handle multiple hosts.</p>
			<p>Or, if you want a little more, with a config file alone it can be set up to serve the pages you need, have rules for CORS, serve the same file for multiple URLs, redirect users to the HTTPS version of your site when they request an upgrade and a huge amount more.</p>
			<p>But, if you want more control, you can write JavaScript files that has access to an extensive API that gives you any level of control, from simply observing requests and responses, to forcing client downloads, to adding compression or templating to your served files, to taking full control over any amount of requests, based on any factors.</p>
			<p>The API for extensions also gives you simple and easy control over loads of things, such as CORS rules, caching, having aliases for hosts and pages, full account systems, that allow you to restrict pages, provide a login service and keep track of users.</p>
			<p>You can even use the API to go as far as implementing custom HTTP methods, and if the API doesn't satisfy your needs, then you can jump in and take over full control over any request at any time and handle it just as you would a normal server request in Node.js.</p>
			<p>Anything is possible with JOTPOT Server. And since it is based on Node.js, if something isn't build in, then you can use an extension to take full control over relivent URLs, requests with specific headers, methods, or anything else and handle the request just as you would with any other Node.js server (plus a few quality of life improvments that are there in the background if you choose to use them).</p>
			<p>JOTPOT Server can suit your projects needs.</p>
			<p>And, every line of code is completally open source and free! Forever.</p>
			
			<h3>Why run a web server in the first place?</h3>
			<p>Being here, I assume you have good motivations already, so I will keep this short.</p>
			<p>A web server can basicaly do anything, just look at Google Docs, or any other website you go to.</p>
			<p>Whether you want to run a blog, forum, service, shop, publication or anything on the web, you're going to need a server. And for some use cases JOTPOT Server is the choice for you.</p>
			<p>If your running a simple infomation site, JOTPOT Server will work great for you, simpily by adding your HTML code (that you can write yourself or use another programme to generate for you) to a directory on your server and running JOTPOT Server, your site will be up in seconds (maybe a minute or two depending on how type you can fast).</p>
			<p>Or, if you're building an online service or web app, JOTPOT Server is perfect, this was what the extension system was designed for. Run your JavaScript code server-side to do whatever you like, you can access everything you would normally access in Node.js, plus loads of simple APIs for interacting with the build in fetures in JOTPOT Server (all of which can be overriden with your own custom implementations). There truely are no limits.</p>
			<p>Anything else is possible too, although there may be more elegant solutions out there for some projects (but if you want to use JOTPOT Server, I ain't going to stop you!).</p>
			
			<h3>Download and installation</h3>
			<p>So, you have decided that you want to use JOTPOT Server (JPS)! YAY!!! Let's get started!</p>
			<p>To start, please make sure that you have a working installation of Node.js on your system. JOTPOT Server first checks through the PATH environment variable for a file called nodejs, then for one called node, so one of them should point to an installation of Node.js. It is recommended that you use the current LTS release of node. If you don't want a systemwide installation, then after you have installed JOTPOT Server, create a directory named node in the directory with the binary files in, and place the node executable in there.</p>
			<p>Next up, if upgrading, we recomend removing the old installation first.</p>
			<p>First off, download the correct package for your system, for downloads, see jotpot.uk/server or for more downloads (for even more platforms), see jotpot.uk/releases/26A-1/downloads.html</p>
			<p>You could also get the file via the command line via the following URL: https://jotpot.uk/releases/$VERSION/jps-$OS-$ARCH.tar.gz.</p>
			<p>Here is an exmaple of downloading version 26A-1 on linux for a x86-64 CPU:</p>
			<pre>
			wget https://jotpot.uk/releases/26A-1/jps-linux-x86-64.tar.gz</pre>
			<p>Next up, we recommend installing JOTPOT Server to the /usr/local/jps directory, if you wish to install it to a different directory, follow these same instructions, but with your own directory path.</p>
			<p>Installing will almost definatily require root priviliges, so you might want to run these commands in a root shell, use 'sudo su' to start a root shell.</p>
			<p>First, lets create the directory to install jps to. An example on linux:</p>
			<pre>
			mkdir /usr/local/jps</pre>
			<p>Next up, we need to extract the contents of the archive we downloaded to the install location, so the executables jps, jpsd and jpslb, along with the jps-main directory are in the root of your chosen directory. Another example on linux, extracting it into the /usr/local/jps directory:</p>
			<pre>
			tar -C /usr/local/jps -xzf jps-$OS-$ARCH.tar.gz</pre>
			<p>Next up, add it to the path. Again, an example on linux:</p>
			<pre>
			export PATH="$PATH:/usr/local/jps"</pre>
			<p>If you want to make this perminant, add it to the profile file. Either to /etc/profile for all users or ~/.profile for only your user.</p>
			<p>To test everything is working, run the 'jps' command. You should get an error saying that the sites directory must exist, or, if it does exist, then the server will boot up, just use ctrl^c to kill it.</p>
			<p>The 'jpsd' command, or 'jps start-daemon' command will start the daemon. If you want it to start on boot, you can use your init system to start it up (run 'jps start-daemon'), if you have systemd, then the 'jps make-unit-file' command will generate a unit file based on your current installation. To add this unit file as a service, run the following commands:</p>
			<pre>
			jps make-unit-file>/etc/systemd/system/jps.service</pre>
			systemctl enable jps
			#To start the daemon now
			systemctl start jps</pre>
			<p>If you want to run all those steps in one go, just start a root terminal ('sudo su') and paste in the following (but add your own system options, and leave out the unit file creation if you arn't using systemd)</p>
			<pre>
			#Set preferences
			OS="linux"
			ARCH="x86-64"
			VERSION="26A-1"
			#Download archive
			wget https://jotpot.uk/releases/$VERSION/jps-$OS-$ARCH.tar.gz
			#Create directory, extract and delete that archive
			mkdir /usr/local/jps
			tar -C /usr/local/jps -xzf jps-$OS-$ARCH.tar.gz
			rm jps-$OS-$ARCH.tar.gz
			#Add it to the path (you might want to add this line to the profile file to make this perminant)
			export PATH="$PATH:/usr/local/jps"
			#Create the unit file
			jps make-unit-file>/etc/systemd/system/jps.service</pre>
			systemctl enable jps
			#Start the daemon now
			systemctl start jps</pre>
			
			<h3>Setting up and an introduction</h3>
			<p>Now that we have JOTPOT Server installed, we can get on with setting it up.</p>
			<p>JOTPOT Server is controled in three manners, first is the config file, secondly is the command line arguments, and finally is the extensions.</p>
			<p>The config file is named 'config.json' and is (just incase you hadn't caught on) a JSON file (yes, that's right, the json file extension means that it is a JSON file!!! I bet I have just blown your mind). The server first checks in the working directory for the config file, then if it cannot find it there, in the jps-main directory (within the directory that jps was installed to).</p>
			<p>All of the properties of the config file are documented below, however we will talk about a few in this introduction. Later on, I will explain how one can be autogenerated, so hold your horses for a moment and read on for a bit.</p>
			<p>Next up, the flags (again documented below), if any of these are set, they override the relivent config property. They override it by changing it when it is loaded. The accual file is not modified, but after it is parsed, the relivent properties in the parsed object are changed.</p>
			<p>Finally the extensions. A more detailed expplanation of extensions are given below, but for now, all I will say is that the server.config object represents the config file, and thus any changes the that object change how the server works, so any changes the extensions make overrides the config file and the flags. It is also possible for extneions to change the way a file is handled in many other ways, including while it is being handled.</p>
			<p>Another file that the server requires is the error template, this is the file that is sent whenver an error occurs, it contains the error information that should be showen to the user. In the default config file, this is named 'errorTemp.jpt' and at the moment is shared accross all sites hosted by the server instance (this will be improved soon, probnably in 26B). If this file doesn't exist, the server has a built in default, so you don't really need to worry too much about this file if the server isn't for production use.</p>
			<p>Next up, we will talk about how files are served by the server. Understanding this is important because if used properly, many shortcuts can be used to make setting up the server much more simple, and maintaining it a whole lot eisier.</p>
			
			<span ID="how-jotpot-server-serves-files">
				<h2>How JOTPOT Server serves files</h2>
				<p>The sites directory is different for each server instance and should be located inside the working directory. It should consist only of directorys, each one being for a seperate host.</p>
				<p>When JOTPOT Server recievs a request for a file, it first checks for a directory named <b>hostname;port</b>. <b>Note how the ':' in the host is replaced with a semi-colon, making it suatable for most file systems.</b></p>
				<p>If that directory doesn't exist, it checks the config for the property "fallbackToNoPort". If true, it next checks for the directory named only the hostname (so without the port).</p>
				<p>Then, if that doesn't exist, it checks the "useDefaultHostIfHostDoesNotExist" property of the config. If true, it repeats the last steps, but with the default host defined by the "defaultHost" property of the config file, so (if the "defaultHost" property is "default:0" - which it is in the default config file) it will find the directory "default:0" if it exists, or "default" if it doesn't (config.fallbackToNoPort is ignored for the default host, it will fallback to no port either way).</p>
				<p>Please note, that is caches all the directorys in the sites directory on boot, so if a directory is added while the server is running, it won't register it. Use the 'jps restart' command to restart the server and thus recache the directorys.</p>
				<p>Then after finding the corresponding directory for the host, it joins the working directory, with sites, the corresponding directory and finally the pathname requested.</p>
				<p>It then stats this new path, if it is a file, it serves the file, if it is a directory, it joins "index.html" to the path and stats that file, if it exists, it serves it. If it isn't a directory and doesn't exist, it adds the extension '.page' and stats this new path. If it is a file, it serves the file. If a file to serve cannot be found, the server responds with a 404 error.</p>
				<p>If the "enableLearning" property of the config file is true, it will store the final served path and link it to the request path, so that next time the same request is recieved, it doesn't have to run the checks. This learning feture can vastly speed up response times so is highly recomended.</p>
			</span>
			
			<h3>Back to the intro! - Finishing the setup and adding your site</h3>
			<p>So, to set up JOTPOT Server, you need a config.json file, a sites directory and idealy a error template file. Luckily, there is a command that can set all this up for you. This is the 'jps setup' command. Basically, this uses the defaultConfig.json and the defaultIndex.html file (both in the archive you extracted to install) to setup a simple server for you. Navigate into the directory you want to setup the server in (use the 'cd' command) and run 'jps setup', as long as there are no errors, the current directory should now have all the files you need for a simple HTTP server, and you can modify them to suit your needs at will and make it as complex as you like.</p>
			<p>So, we have a basic setup, let's add your website. Obviously, if you are running your site as a website for a web browser, the web pages are all writen in HTML (you can write one yourself, or, if you like, there are loads of pieces software out there that will ganerate the HTML for you), after running the setup command, a simple HTML file will have been created for you, you can use this for testing purposes if you like. However, at some point you will need to add your site, you can do it now, or complete the setup and add it afterwards, either way, the instructions still stand.</p>
			<p>Based on the section above about how JOTPOT Server finds files, we know that if we just want out server to serve you site for any hosts, we add it to the default directory ("sites/default" if you haven't changed the config). If you want to host a few sites, on the same server, then you determine the hosts you want to host, I am going to use example.com and example.net for the purpose of illustration, you would set up 2 directorys, one named "example.com" and the other named "example.net" - both within the sites directory. Make sure that the "fallbackToNoPort" property of the config file is true as otherwise it will only look in the directorys with the port numbers, and place each site within their corresponding directorys, and now, when the user connects via example.com, they will be served the content from the example.com directory, and when the user makes a request from the example.net host, it will serve the content from the example.net directory.</p>
			<p>If you want to have different content for example.com for a different port, say "example.com:5" should take the user to a different site, then simply create a directory named "example.com;5" (yes, that is a semi-colon), and when example.com:5 is the host, the server will serve that content, but with any other port, it will serve the content from the example.com directory.</p>
			<p>But let's now say that you want to have 2 different hosts serving the same site, for example example.com and example.jotpot.uk could both be domains for what you want to be the same site, for this, you can use the "hostAlias" property of the config.json file. This is an object, where each key is a host, and it's value it's alias. So if we want both the HTTP version of example.jotpot.uk and the HTTPS version of example.jotpot.uk to serve the same content as example.com, then we would set the value of the hostAlias property to '{"example.jotpot.uk:80": "example.com:80", "example.jotpot.uk:443": "example.com:443"}'. Now example.jotpot.uk will be treated as example.com on both port 80 (default HTTP) and port 443 (default HTTPS).</p>
			<p>However, there is a better way of doing this, the "hostnameAlias" property, although in some cases you only want a specific host to be an alias, in most cases, you will want the hostname to be an alias. If we set the hostnameAlias property to '{"example.jotpot.uk": "example.com"}', then all requests for example.jotpot.uk will be treated as a request for example.com, however the port in the host will not change. So a request for the host example.jotpot.uk:80 would be treated as a request for the host example.com:80 and one for example.jotpot.uk:5 would be treated as one for example.com:5. Please note that the "hostAlias" property is checked first, so to avoid this, you could set example.jotpot.uk:5 to an alias of "example.jotpot.uk:80" (or just example.com:80).</p>
			<p>There are also a couple more properties that relate to hosts, the "hostRedirects" and the "hostnameRedirects" property, these are treated the same as their alias counterparts, however the user is instead redirected to the same URL, but with the alias applied. So if the hostnameRedirects property was '{"example.jotpot.uk": "example.com"}', then when the user requests "example.jotpot.uk/hello/world", they would be redirected to "example.com/hello/world".</p>
			
			<h3>Running the server</h3>
			<p>There are a couple of ways to run the server. The most simple is to just run the 'jps' command in the server directory, this will start up the server in the directory (however it will be in the foreground and not managed my anything, so a crash won't be handled nor the logs stored).</p>
			<p>The second method requires the daemon to be running (I touched upon this in the installation guide, so scroll back up if you need help with that). This is similar to the last method, navigate to the server directory in the terminal, and then run 'jps start', this will instruct the daemon to start the process in the directory you are running the command from. After it is started it will continue running in the background, even when the starting user logs out. It will be stopped only be the user or a system reboot.</p>
			<p>If you want to ensure the server stays up in the case of an unrecoverable error, you can use the -keepalive option (add it at the end of your command), this will cause the daemon to spawn an identicle server if the created one errors - it will have all the same arguments and the same working directory.</p>
			<p>To manage servers under the daemon, there are a few useful commands. First off, is the 'jps list' command, this lists all the servers, their state (either running, errored or stopped), and their working directory.</p>
			<p>Next up, the 'jps stop' and 'jps restart' command. Both of these take one extra argument, this is the ID of the server to perform the action on. So if you were running 'jps stop' you would first run 'jps list' and find the ID of the server you want to stop, then you would run 'jps stop x' where x is the ID of the server. The 'jps stop' command, stops the given server, and 'jps restart' stops it and spawn a new server with all the same flags and working directory (note that the new server will also recieve a new ID).</p>
			<p>You will also probably want to view the logs of the servers, there are curerntly 3 types of logs, 'info', 'error' and 'logs'. The 'info' logs are the logs from the standard output of the server, these are vital logs, such as thread statuses, cacheing errors and config parsing errors, along with anything logs by console.info in the extensions. The 'error' logs are the logs printed from the standard error output, so any fatal errors will be logged here (note that non-fatal, handled errors will be loged to the 'logs' logs). The 'logs' logs are the main server logs, these contain request logging, general info logging and any handled erorrs. The 'logs' logs are however only available when the server is running, this is because to improve speed they are kept in memory owned by the server, and when you request the logs, they are printed to the screen via a socket connecting to the server, the info and error logs on the other hand are available at any time, including ater the process has been stopped or has errored. These logs can be viewed via he 'jps info', 'jps error' and 'jps logs' commands, all of which take the ID as their only argument.</p>
			<p>But wait! I know what you're thinking! Does this mean that I have to run 'jps start' every time I boot up my server, will I have to bother making a unit file for that??? Don't worry, we thought of that too! (And if that wasn't what you were thinking, then I'm sorry, because this is the best we've got.)</p>
			
			<h2>The jps-servers file</h2>
			<p>This file is located at /etc/jps-servers (on most systems) or %PROGRAMDATA%/JOTPOT/jps-servers (on Windows). It is a simple text file, where only LF is used as the new line character (so only "\n" rather than "\r\n" as is the default on Windows, sorry if your really Windowsee).</p>
			<p>Each line defines a server that will be automaticaly started as soon as the daemon starts up. Each line is a set of properties seperated by a space, the first property is the working directory of the server, and the rest are arguments to pass to the server. So a jps-servers file might look like this: "/server -keepalive\n/home/coolperson/website -keepalive -port 8080". If so, the daemon would create 2 servers, one in the working directory "/server" and with the argument "-keepalive", and the other in the working directory "/home/coolperson/website" with the arguments "-keepalive -port 8080".</p>
			
			<span ID="learning">
				<h3>Learning</h3>
				<p>JOTPOT Server has a feature called learning, it is enabled by the enableLeaning property in the config.json file. It speeds up typcal usage segnificantly.</p>
				<p>When learning is enabled, JPS will remember the file served for a request URL, and thus not have re run the same checks next tiem the request is recieved. An example of this, is when a user requests a directory and the index.html file is served, JPS has to stat the directory to find out that it is a directory, and then stat the index.html file to check it exists. However if learning was enabled, these checks would be run the first time the directory is requested, however subsicent requests made for the directory will be automaticaly served the index.html file without the server having to stat the directory (speeding things up a little). If there are handlers on the page, it will not be learned (to allow the handler to change the URL).</p>
				<p>API functions such as server.unlearn and server.isLeaned can be used for making sure incorrect pages are not learned.</p>
			</span>
			
			<!--
			<p></p>
			<p></p>
			<p></p>
			
			
			
			On windows, you will have to add a firewall exception, and on Linux, if you are creating a server on a privileged port (port number below 1024), you will have to run it as root, so begin the command with sudo - although this isn't recommended, you can set it up so that traffic into port 80 goes to port 8080 for example either on your router or with iptables on Linux, there is a <a href="https://www.cyberciti.biz/faq/linux-port-redirection-with-iptables/" target="_blank">guide from nixCraft here</a>.
			<br>Now, you can load up your browser, and head to http://localhost:&lt;YOUR PORT NUMBER HERE&gt;. This will load up the index.html page in your localhost;&lt;YOUR PORT NUMBER HERE&gt; directory. Then, go to http://localhost:&lt;YOUR PORT NUMBER HERE&gt;/page2.html and you will see your other web page, or go to http://localhost:&lt;YOUR PORT NUMBER HERE&gt;/page3 to see your page3.page file.
			<h3>Going a bit further (just a bit, we haven't even got to extensions yet ;)</h3>
			Now, you can try and access your server from another computer! To do this, find your local IP address, in Linux, use the ifconfig command, work out which interface you are using (mine is eth0, as it is the first eth (ethernet connection), you might be using wlan0 or a separate one) and read off the inet addr value, for example 192.168.1.103. And on windows use the ipconfig command, work out which adapter you are using, mine is the 'Ethernet adapter Ethernet', as mine is an ethernet connection, and read off the IPv4 Address value, again could be something along the lines of 192.168.1.103.
			<br>Remember those numbers. Go to another PC (for now, make sure it is on the same local area network (LAN) as the PC you are using as the server), and open the web browser. No go to http://&lt;YOUR.IP.ADDRESS.HERE&gt;:&lt;YOUR PORT NUMBER HERE&gt; (you don't need to add the :PORT part if you are using port 80 as 80 is the default port for HTTP).
			<br>You will notice that it responds with a 404: Not Found error, this is because it is now looking in 'sites/&lt;YOUR.IP.ADDRESS.HERE&gt;:&lt;YOUR PORT NUMBER HERE&gt;' for index.html, we could solve this be creating a new directory with that name. But we could also use a feature of JOTPOT Server called host aliasing. This allows you to set an alias up for a host, so host-a.com could be processed as host-b.com. We can set this alias in the config.json file. Find the property named "hostAlias". In the default config, the value will be '{}', if we set it to '{"host-a.com":"host-b.com"}', then host-a.com will be handled as host-b.com. This can continue as such: '{"host-a.com":"host-b.com", "some-other-website.co.uk":"some-other-website.com"}'. With a comma separating the values.
			<br>So to set up the alias you want, we can set the "hostAlias" property to '{"&lt;YOUR.IP.ADDRESS.HERE&gt;:&lt;YOUR PORT NUMBER HERE&gt;":"localhost:&lt;YOUR PORT NUMBER HERE&gt;"}'
			<br>Then, reboot the server. So this by focusing on the command window it is running in and pressing ctrl+c to kill the programme. If this doesn't work on Windows (due to changed defaults), just close the window. Then rerun the server and the config.json will be reloaded. Now try from the other computer again and your index.html file should pop up!
			<br><br>To connect to your server from another PC that is not on your network, you will need to know your global IP address, the one that points to you from outside of your LAN. You can get your global IP address from <a href="https://jotpot.co.uk/whatsmyip" target="_blank">jotpot.uk/whatsmyip</a>. You will then need to set up your router to let traffic on your chosen port get to your PC, this is known as port forwarding. Make sure that the port you want to use externally (this could be port 80, the default for HTTP remember or another port), forwards to the port that the server is running on on your PC.
			<br>There are some guides available for setting port forwarding up from: <a href="http://www.pcworld.com/article/244314/how_to_forward_ports_on_your_router.html" target="_blank">PCWorld</a>, <a href="http://www.wikihow.com/Set-Up-Port-Forwarding-on-a-Router" target="_blank">wikiHow</a>, <a href="http://bt.custhelp.com/app/answers/detail/a_id/8790/~/how-do-i-set-up-port-forwarding-on-my-bt-hub?" target="_blank">BT</a>, <a href="https://www.howtogeek.com/66214/how-to-forward-ports-on-your-router/" target="_blank">How-To Geek</a> and many others with <a href="https://www.google.com/search?q=how+to+set+up+a+port+forward" target="_blank">a quick Google search for "how to set up port forwarding"</a> (the How-To Geek one goes in to the most exciting detail)
			<br>Then, you will need to set up another host alias (just as we did before), but this time from &lt;YOUR.GLOBAL.IP.ADDRESS&gt;:&lt;The port you chose to forward from&gt; - remembering that if we chose port 80, we don't need the ':80' at the end. And still to 'localhost:&lt;The port your server is running on&gt;'
			<br>Reboot the server once more and try to connect via your global IP. If all is good, you should be able to access your web server from anywhere in the world now. However you might need to bare in mind that if you have a dynamically assigned IP address, your IP address will change from time to time, so you might need to keep on top of that.
			<br>From there, you can buy a domain name and point that to your IP and turn your website into whatever you like.
			<br>Buying a domain is one way to prevent the constant changing of the host aliases in the config file, but, as mentioned earlier, another way would be to use the default host.
			<br>So for this, lets rename out localhost directory to 'default', this could be anything, but default makes sense. We should then set our "defaultHost" property in the config.json file to the name of our directory. Luckily, the default one you downloaded, already has this. Then make sure that the "useDefaultHostIfHostDoesNotExist" property is set to true, before rebooting the server. You can also remove all the aliases now as they are no longer required.
			<br>After the reboot, no matter what host you use to connect to your server, as long as there isn't a directory for it, it will use the 'sites/default' directory, however if you were to register 2 domains, say "host-a.com" and "host-b.com", you could still have separate directory's for them 'sites/host-a.com' and 'sites/host-b.com', while everything else will go to 'sites/default'.
			<br><br>The rest of the docs dive deeper into JOTPOT Server, it covers the config.json file and also extensions - that give you the power to modify the behaviour of JOTPOT Server and add server-side logic and scripting. Have fun and thank you for using JOTPOT Server :)
			<br><a href="https://github.com/JOTPOT-UK/JOTPOT-Server" target="_blank">JOTPOT Server is all open source on GitHub, so if you encounter any problems, or have any features would like to suggest or add yourself, head over there.</a>
			<br><br>-->
		</div>
		<h2>Command reference</h2>
		<div class="indent">
			<p>JOTPOT Server has 3 commands, these are 'jps', 'jpsd' and 'jpslb'</p>
			
			<h3>The 'jpsd' command</h3>
			<p>Running 'jpsd' is an alias for running 'jps start-daemon'.</p>
			
			<h3>The 'jps' command</h3>
			<p>This is the command used to control the server (not the load balencer).</p>
			<p>It should be used in the format: 'jps [command] [...arguments]'</p>
			<p>If run without a command, it defaults to 'jps run'</p>
			<p><b>Available commands:</b></p>
			<ul>
				<li>error: Prints the stderr of the given server. So 'jps info 5' will print the stderr from server 5.</li>
				<li>info: Prints the stdout of the given server. So 'jps info 5' will print the stdout from server 5.</li>
				<li>list: list lists the servers managed by the daemon, gives a status, either running, errored or stopped, along with their working directory.</li>
				<li>logs: Prints the server logs of the given server. So 'jps info 5' will print the logs from server 5.</li>
				<li>make-unit-file: This generates a systemd unit file that runs the JOTPOT Server daemon based on the current installation.</li>
				<li>restart: restart stops the server given by the first and only argument, and starts one with the same working directory and flags as the one stopped. For example 'jps stop 3' would stop server 3 under the daemon and start a new one with the same working directory and arguments as the one stopped, note that this will start as a new server and thus not share the same ID. (Use 'jps list' to get a list of running servers)</li>
				<li>run: Starts a JOTPOT Server instance in the current working directory. This is bound to the current stdout, stderr and stdin. To stop the server, use control^c to interupt the programme. All given arguments are passed to the server (see the server flga below).</li>
				<li>setup: This sets up the current directory as a simple server. It creates a directory named 'sites', within that, a directory named 'default', and within that a default index.html file. It then creates a simple config.json file and a basic errorTemp.jpt file. After this command is run, the directory can serve as a basic HTTP server listening on port 80.</li>
				<li>start: Instructs the daemon to start a JOTPOT Server instance in the current working directory. Thus once started this instance will run in the background as a child process of the daemon. All given arguments are passed to the server (see the server flga below).</li>
				<li>start-daemon: Starts the daemon.</li>
				<li>stop: stop stops the server given by the first and only argument. For example 'jps stop 3' would stop server 3 under the daemon. (Use 'jps list' to get a list of running servers)</li>
			</ul>
			<p><b>Server flags:</b></p>
			<ul>
				<li>-data: When NOT used under the daemon, this determines the port that the data server listens on.</li>
				<li>-keepalive: When this flag is presant, and the server run under the daemon, if the server crashes, then a new one is started with the same flags and working directory as the current one, to keep it alive.</li>
				<li>-port: Any given port options will be listened on via HTTP, multiple options may be given, for example 'jps start -port 8080 8081 8082 -port 8083', will listen on ports 8080-8083 inclusive.</li>
			</ul>
		</div>
		<h2>The config.json file</h2>
		<span class="indent">This JSON file contains the basic configuration for JOTPOT Server. There are simple versions and demo versions available from <a href="/server">jotpot.co.uk/server</a>. Please note that extensions can modify properties in the server.config object, this will have the effect on the server, however the file will remoained unchanged unless rwriten implicitly.</span>
		<div class="indent">
			Properties:
				<br>
				<br>'addVarsByDefault': Boolean, true to replace anything served in the format "$:::&lt;var name&gt;:::$" with the value of the variable or false to not replace be default.
				<br>'behindLoadBalencer': Boolean. true if headers set be the JOTPOT Server load balencer should be used, for example when determining the source IP address or if the request was HTTPS.
				<br>'cache': Array of Strings. server.cache.cacheFile is called with each item of the array on server boot.
				<br>'controlers': Array of strings. If the array isn't empty, only IP addresses listed in the array are allowed to connect to the data server (this ensures that other divices on the network cannot perform actions on the server).
				<br>'CORS': Array of Arrays. For each item in the array, <a href="#server-addCORSRule">server.addCORSRule</a> is called with the array as the arguments.
				<br>'dataPort': Number||String. The port you would like the server to listen on for data connection (transfering logs and signals), if Number, it listens on 0.0.0.0 on the given port, if it is a string in the format "ip:port", it will listen on the given IP under the given port.
				<br>'defaultHost': String. The host to use by default if the http request contains no host header or useDefaultHostIfHostDoesNotExist is true and the host requested doesn't exist.
				<br>'dontRedirect': Array. When a redirect is considered by the server, it won't redirect if the url value is within this array.
				<br>'doVarsForIfNotByDefault': Array of Strings. Any pages included in this array will have variables added to them even if doing them by default is set to false, they are in the form of the value of the URL (does listen to req.usePortInDirectory, so if the directory name doesn't have a port, than the value shouldn't have the port).
				<br>'errorTemplate': String. The file to use as the error page.
				<br>'enableLearning': Boolean. Whether or not learning should be enabled. See <a href="#learning">learning</a>.
				<br>'fallbackToNoPort': Boolean. If true, when a user makes a request and the host directory doesn't exist, it will try to fall back to the hostname as the driectory (rather than the host). <a href="#how-jotpot-server-serves-files">See 'How JOTPOT Server serves files' for a further description.</a>
				<br>'hostAlias': Object. Similar to hostRedirects however rather then redirecting the server will handle the request as if it came from the host you set - without the user being redirected.
				<br>'hostnameAlias': Object. Similar hostAlias, however only for the hostname.
				<br>'hostnameRedirects': Object. Format: {"host_you_want_redirecting.com": "host_to_redirect_to.com"}, similar to hostAlias, however it only applies the the hostname (so not the port)
				<br>'hostRedirects': Object. Format: {"host_you_want_redirecting.com:xx": "host_to_redirect_to.com:xx"}, when a request is recieved, if the host is a key in this object, the user is redirected to the same URL however with the host changed to the value corresponfing the the key in this object.
				<br>'httpServers': Array. Each item of the array should be an object containing the HTTP server options.
				<br>'httpsServers': Array. Each item of the array should be an object containing the HTTPS server options.
				<br>'mustRedirectToHttps': Array. Similar to redirectToHttps, however the user will be redirected even if they don't request an upgrade - so forces HTTPS (note that the user may not support this).
				<br>'pageAlias': Object. Implemented pre 26A, not currently implemented, use server.cache.createLink from an extension instead. It will be reimplemented soon.
				<br>'redirectToHttps': Array. Each item of the array should be a string of any domains you want to be redirected to the https version of the site if the request requests an upgrade.
				<br>'threads': Number. The number of worker threads the server should start, if 0, so number of CPU cores will be used.
				<br>'useDefaultHostIfHostDoesNotExist': Boolean. true if the default host should be used like an alias if the host the user is requesting does not exist.
				<br>
				<br>HTTP Server Options:
				<br>'port': Number, the port you would like the server to be opened on.
				<br>
				<br>HTTPS Server Options:
				<br>'port': Number, the port you would like the server to be opened on.
		</div>
		<br><br>
		<h2>What are JOTPOT Server extensions and how do they work?</h2>
		<div class="indent">
			JOTPOT Server allows JavaScript files to be run and take control over the server, anything is possible via extensions and 'limited' extensions can be run to ensure an extension can only handle requests etc. from a specific domain/domains for security and stability.
			<br>
			Any file in the working directory of the server, with the full filename ending in '.jpe.js' will be loaded as extensions. There are 2 types of extensions, 'Master' extensions, and 'worker' extensions. JOTPOT Server runs using the 
			<a href="https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html">Node.js cluster modules</a>, 
			this means that there is a master process and then an amount of workers. The master process runs all extensions (where the server.isMaster variable will be true) and each worker runs all the extensions (where the server.isMaster variable is false). 
			They have some shared API features however some different features.
			<br>
			Every extension is loaded with the standard Node.js require function, console object, setTimeout along with the setInterval and setImmediate functions.
			<br>
			There is also a 'server' object for controlling and interacting with the current JOTPOT Server instance, documented below.
			<br>
			The most key consent of extensions is server.handle, and for developing simple applications, it can be all that is needed.
		</div>
		<br><br>
		<span ID="server-object">
			<h2>'server' object</h2>
			<div class="indent">
				<span>The server object is an object available is master and worker extensions, however with differences in each.</span>
				${formatObject("./server-docs.json")}
			</div>
		</span>
		<br><br>
		<span ID="using-server-events">
		<h2>
			Server Events
		</h2>
		<div class="indent">
			JOTPOT Server has a serese of events that extensions can handle to add behavior to or to overwrite the behavior of.
			<br>
			Please see <a href="#server-handle">server.handle()</a> for handling events.
			<br>
			<h3>
				Events:
			</h3>
			<ul>
				<li>'ready' event: This is the first event to fire, this event is fired when the current process is up and ready. This is fired for both master extensions and worker extensions and is the only event currently for master extensions. It cannot be overwritten, so the return value is ignored. The handler is called with no arguments.</li>
				<li>'request' event: This event is fired whenever a request is received, this event is fired before any redirects happen, such as redirects to HTTPS or redirects to the login page, so this should generally not be handled. The default behavior can be overwritten to if the handler returns true or returns a promise that resolves true, JOTPOT Server will stop handling the request. The handler is called with 2 arguments, the request object and the response object.</li>
				<li>'&lt;domain&gt;/request' event: This is the equivalent to the 'request' event however only fires for the domain before the '/'</li>
				<li>'fullrequest' event: This event is fired after a request is redirected and has page/host aliases applied, this event is however fired before any authentication checks happen, so this should generally not be handled if an account system is active of the page. The default behavior can be overwritten to if the handler returns true or returns a promise that resolves true, JOTPOT Server will stop handling the request. The handler is called with 2 arguments, the request object and the response object.</li>
				<li>'&lt;domain&gt;/fullrequest' event: This is the equivalent to the 'fullrequest' event however only fires for the domain before the '/'</li>
				<li>'allowedrequest' event: This event is fired when the server is ready to respond to the event, the user will have gone through all redirects, any aliases will have been applied and the user will be authenticated to access the page they are requesting. In most cases, this is the best event to handle for server side rendering, analytics and most other use cases.</li>
				<li>'&lt;domain&gt;/allowedrequest' event: This is the equivalent to the 'allowedrequest' event however only fires for the domain before the '/'</li>
				<li>'websocket' event: This event is fired when the server recieves a request to upgrade to the websockets protocol. Any callbacks are called with 1 argument, that is a websocket request object (call the accept method to get the response object).</li>
				<li>'&lt;domain&gt;/websocket' event: This is the equivalent to the 'websocket' event however only fires for the domain before the '/'</li>
			</ul>
		</div>
		<br><br>
			<h2>
				Using server.handle
			</h2>
			<div class="indent">
				So, lets say you want to render a page serverside for the user, you could use the serveer.handle function to create this functionality.
				<br>
				When you handle any request event, so 'request', 'fullrequest', 'allowedrequest' or any host specific request, the handler function will receive 2 arguments, the request and the response object. These are documented below.
				<br>
				Here is an example:
				<pre>
				//Handle the request when we know it is allowed, to ensure that
				// we don't serve a page to a user that isn't logged in.
				server.handle('allowedrequest', (req, resp) => {
					
					//The request and response object have everything the standard
					// Node.js objects have however with some modified properties
					// and some additional ones.
					
					//Note how the domain is at the start of the req.url, see
					// req.url in the request docs below for how it is different.
					// You might also want to use req.purl here instead.
					if (req.url === 'www.exmaple.com/content.html') {
						
						//Call you own function to hamdle the request and the
						// response as you would in any other Node.js server.
						renderContentPage(req, resp) ;
						
						//Return true to say that this has handled the event
						// so the default behavior gets overwritten.
						return true ;
						
					}
					
					//If we haven't handled it, return false so the server 
					// continues with the default behavior for the request.
					return false ;
					
				});
				</pre>
			</div>
		</span>
		<br>
		<span ID="request-object">
			<h2>
				The 'request' ('IncomingMessage') object.
			</h2>
			<div class="indent">
				The 'request' object is passed as the first argument to any hander function handling a request - with the second argument always been the response object. It is the <a href="https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_class_http_incomingmessage">Node.js IncomingMessage object</a> however has some modified properties and some added properties to make working with it easier. All of these changed/additional properties are listed below.
			</div>
			<div class="indent">
			${formatObject("./req-docs.json")}
			</div>
		</span>
		<br><br>
		<span ID="response-object">
			<h2>
				The 'response' ('ServerResponse') object.
			</h2>
			<div class="indent">
				The 'response' object is always passed to the request hander as the second argument, and similar to the 'request' object is the <a href="https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_class_http_serverresponse">Node.js ServerResponse object</a> however with a couple of added properties for ease of use. These added properties are documented below.
			</div>
			<div class="indent">
			${formatObject("./resp-docs.json")}
			</div>
		</span>
		<br><br>
		<span ID="url-object">
			<h2>
				The 'url' object.
			</h2>
			<div class="indent">
				The 'url' object is an object that is used to describe a URL. By default, request.url is a url object representing the request URL.
				<br>You can also create your own url object using <a href="#server-createURL">server.createURL</a> and <a href="#server-createURLFromString">server.createURLFromString</a>.
				<br>An url has a value that is a string, which is the same as the value property, and thus url == url.value however url !== url.value.
				<br>Most of it's properties are setters and getters and thus when one property is changed, the others echo the change. So changing the port proprty will also change the host property, the origin property and etc.
			</div>
			<div class="indent">
				${formatObject("./url-docs.json")}
			</div>
		</span>
		<br><br>
		<span ID="ws-intro">
			<h2>
				WebSockets in JOTPOT Server
			</h2>
			<div class="indent">
				<p>WebSockets is an incredably powerful tool in developing web apps, and from JOTPOT Server 26B onwards, support for it is built in.</p>
				<h3>A quick intro to WebSockets</h3>
				<p>WebSockets is a protocol that can be used by JavaScript in a browser to start a session with the server, either the client or the server can then send messages to eachother at any time. WebSockets is fast keeps the socket open, meaning that there is minimal latency, and the server can send messages to the client at any time without having to be polled.</p>
				<p>You can read more about the WebSockets protocol and see the browser API reference at <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank">developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a>.</p>
				<h3>Using WebSockets in JOTPOT Server</h3>
				<p>When a WebSockets session is started, a HTTP Upgrade request is send by the client, requesting to be upgraded to WebSockets, when JOTPOT Server recieves one of these requests, it triggers the 'websocket' event. By using <a href="#server-handle">server.handle</a> you can add your behavior for all WebSocket upgrade requests, or you can use </p>
				<h3>Example extension (filename must end in .jpe.js and must be in the working directory of the server):</h3>
				<pre>
	//Only run if we are a worker
	if (!server.isMaster) {
		const {Buffer} = require("buffer") ;
		server.handleWebSocket("localhost:8080/ws.example", req=>{
			//Accept the session (in production, you should always check origins etc.)
			req.accept((err, resp) => {
				if (err) {
					//Throw if there was an error
					throw err ;
				}
				req.on("text", text => {
					//When we get a text message, log it out.
					console.info("Text message:", text) ;
					//And send a message back, saying "Your message: $TEXT"
					//Write the first frame with the first part of the message
					resp.write("Your message: ") ;
					//Then write the end frame with the second part of the message
					resp.end(text) ;
					
					//This could also be done as
					// resp.end("Your message: "+text)
					//Which would be more efficient as it would be sent as a single frame.
					//However 2 frames have been sent for purposes of example.
				}) ;
				req.on("binary", buff => {
					//When we get a binary message, log it as hex.
					console.info("Binary message:", buff.toString("hex")) ;
				}) ;
				
				//Send a text message saying "Hello!"
				resp.end("Hello!") ;
				setTimeout(() => {
					//After 5 seconds, send a binary frame with the data 010203.
					resp.end(Buffer.from([1,2,3])) ;
				}, 5000) ;
			}) ;
			//Must return true to say we've handled it, if we don't, the server ends the socket for safety purposes.
			return true ;
		}) ;
	}</pre><h3>Example browser code:</h3><pre>
	//Create WebSocket connection.
	const socket = new WebSocket("ws://localhost:8080/ws.example") ;

	socket.addEventListener("open", () => {
		//Send a message when the connection is made
		socket.send("Hello from the client!") ;
		socket.send(new Blob([123,12,1])) ;
		setTimeout(() => {
			//Send another message 3 seconds later.
			socket.send("3 seconds later.") ;
		}, 3000) ;
	}) ;

	//Add an event listener for a message
	socket.addEventListener("message", event => {
		if (event.data.constructor.name === "Blob") {
			//If it is a binary message, Create an ArrayBuffer from the result
			let reader = new FileReader() ;
			reader.readAsArrayBuffer(event.data) ;
			reader.addEventListener("loadend", () => {
				let arr = new Uint8Array(reader.result) ;
				//Log the data
				console.log("Binary message from server:", arr.join(",")) ;
			}) ;
		} else {
			//If it's a text message, just log the text
			console.log("Text message from server:", event.data) ;
		}
	}) ;

	//Log that we are closed if the connection is closed.
	socket.addEventListener("close", () => {
		console.log("Connection to server closed!") ;
	}) ;</pre>
			</div>
		</span>
		<br><br>
		<span ID="wsrequest-object">
			<h2>
				The 'wsrequest' object.
			</h2>
			<div class="indent">
				<p>This object is used to represent the WS upgrade request and all incoming WS messages.</p>
				<p>It is an event emmiter that emits events for recieved messages, it containes information about the HTTP request for the upgrade (such as headers, version etc.), the socket for the connection and some methods used to control the WebSockets session.</p>
				<p>The most important method being wsrequest.accept, this accepts the upgrade request and generates the wsresponse object, so at the start of any WebSockets session wsrequest.accept() must be called. See the documentation on it for more details.</p>
			</div>
			<div class="indent">
				<h3>Events:</h3>
				<p>'text': Emited when a text message is recieved, the callback recieves the text message as a string as the only argument.</p>
				<p>'binary': Emited when a binary message is recieved, the callback recieves the binary message as a Buffer as the only argument.</p>
			</div>
			<div class="indent">
				${formatObject("./wsreq-docs.json")}
			</div>
		</span>
		<br><br>
		<span ID="wsresponse-object">
			<h2>
				The 'wsresponse' object.
			</h2>
			<div class="indent">
				<p>This object is used to represent the WS communication from the server to the client.</p>
				<p>The most important consept to wsresponse is the difference between frames and messages, a message can be a single frame, or more than one frame. The wsresponse.write function is used to send a frame, if the isEnd argument is true, then when the client recieves this frame, it will create a message based on all frames recieved since the last end frame. So you could send a single frame that is the end and would thus be a message, or multiple frames in a row that all come togoether to make a message. Also, rather than calling wsresponse.write with the isEnd argument every time, you can rely on its default being false and use wsresponse.end to call wsresponse.write with isEnd as true. An important note here is that wsresponse.end doesn't end the session, it only ends the current frame, to end a session, call wsrequest.socket.end().</p>
				<p>For good practice, you should always use <a href="#wsresponse-que">wsresponse.que</a> to ensure to don't mix up frames for your messages.</p>
			</div>
			<div class="indent">
				${formatObject("./wsresp-docs.json")}
			</div>
		</span>
	</div>
</div>
<jp-data-title>JOTPOT Server Docs</jp-data-title>
<script type="text/javascript">
	addClickListener(document.getElementById("the_link")) ;
</script>